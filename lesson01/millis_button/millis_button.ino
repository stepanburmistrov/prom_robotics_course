/*
================================================================================
Урок: Асинхронное мигание и антидребезг кнопки с INPUT_PULLUP
Проект: «Светофор без delay()»

ЦЕЛИ УРОКА
1) Научиться мигать несколькими светодиодами одновременно без delay() при помощи millis().
2) Понять, как работает встроенная подтяжка INPUT_PULLUP.
3) Реализовать надёжную реакцию на кнопку (антидребезг) и простую «машину состояний» на флагах.
4) Разобраться, что такое «асинхронная логика» и зачем хранить таймеры.

СХЕМА ПОДКЛЮЧЕНИЯ 
- Красный светодиод (через резистор 220–330Ω) к D2 → другой вывод светодиода в GND.
- Жёлтый светодиод (через резистор 220–330Ω) к D3 → GND.
- Зелёный светодиод (через резистор 220–330Ω) к D4 → GND.
- Кнопка к D5 и GND. Внешний резистор НЕ нужен: мы включим INPUT_PULLUP!
  (Это значит: когда кнопка НЕ нажата — на входе логическая 1; когда нажата — логический 0)


ИДЕИ
- Никаких delay() — они «замораживают» процессор и мешают делать несколько задач сразу.
- millis() возвращает число миллисекунд с момента старта; мы сравниваем «текущее время – время_старта > интервал».
- Для устойчивой кнопки нужен антидребезг (обычно 10–50 мс). Здесь задано 5 мс — это «минимально допустимо».
- Логика кнопки инвертирована: из-за INPUT_PULLUP «нажато» = 0, «отжато» = 1. Мы переворачиваем её оператором инверсии «!».

- Тип таймеров лучше делать unsigned long (классический вариант Arduino против переполнения).
  В коде используется long — для учебной простоты, но в реальном коде меняйте на unsigned long.
- Оператор «and» — это допустимый синоним «&&» в C++. Для индустрии чаще используют «&&».
- Комплексирование операторов digitalWrite(pin, !digitalRead(pin)) удобен для «переключения».
- Интервалы выбраны разные (100 мс, 235 мс), чтобы показать независимость таймеров.

ПРАКТИКА (сделайте после запуска)
1) Измените длительность жёлтого мигания на 500 мс — посмотрите, как меняется рисунок.
2) Сделайте, чтобы зелёный светодиод менял состояние только при отпускании кнопки (событие «release»).
3) Превратите блок с красным/жёлтым в функцию blink(pin, interval, timer).
4) Усложнение: длинное нажатие (>1 с) включает зелёный постоянно, короткое — переключает.

ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ
- Почему delay() мешает мигать несколькими светодиодами одновременно?
- Чем хорош INPUT_PULLUP и почему кнопку подключаем к GND?
- Что такое «антидребезг» и для чего нужен флаг buttonPressed?
- Почему сравнивают «millis() - timer > interval», а не «millis() > timer + interval»?

================================================================================
*/

int greenPin  = 4;  // Пин зелёного светодиода 
int yellowPin = 3;  // Пин жёлтого светодиода
int redPin    = 2;  // Пин красного светодиода
int buttonPin = 5;  // Пин кнопки (кнопка между D5 и GND, включим INPUT_PULLUP)

// Таймеры для каждого независимого процесса мигания/дребезга.
long timerRed   = 0;
long timerYellow= 0;
long timerGreen = 0;

// Переменные для логики кнопки
int button = 0;          // Текущее состояние кнопки после инверсии (!digitalRead)
int buttonPressed = 0;   // Флаг «кнопка находится в нажатом состоянии» (машина состояний: 0→1→0)

/*
setup() — однократный вызов при старте.
- Выводы светодиодов — OUTPUT.
- Кнопка — INPUT_PULLUP (включает внутреннюю подтяжку к VCC → экономим резистор и места на макетке).
*/
void setup()
{
  pinMode(redPin,    OUTPUT);
  pinMode(yellowPin, OUTPUT);
  pinMode(greenPin,  OUTPUT);

  pinMode(buttonPin, INPUT_PULLUP); // НЕ нажата: HIGH (1). Нажата: LOW (0).
}

/*
loop() — главный цикл. В нём три независимых «задачи», каждая со своим таймером:
1) Красный мигает каждые ~100 мс.
2) Жёлтый мигает каждые ~235 мс.
3) Зелёный переключается при нажатии кнопки (с антидребезгом ~5 мс и флагом, чтобы не «дребезжало»).
*/
void loop() 
{
  // ────────────────────────────────────────────────────────────────────────────
  // 1) Асинхронное мигание КРАСНЫМ без delay()
  // Проверяем, прошло ли 100 мс с последнего переключения.
  if (millis() - timerRed > 100) {
    // Переключаем состояние вывода: если было 1 — станет 0, и наоборот.
    digitalWrite(redPin, !digitalRead(redPin));
    // Запоминаем «время последнего переключения»
    timerRed = millis();
  }

  // ────────────────────────────────────────────────────────────────────────────
  // 2) Асинхронное мигание ЖЁЛТЫМ без delay()
  if (millis() - timerYellow > 235) {
    digitalWrite(yellowPin, !digitalRead(yellowPin));
    timerYellow = millis();
  }

  // ────────────────────────────────────────────────────────────────────────────
  // 3) Обработка КНОПКИ с антидребезгом и флагом состояния
  // INPUT_PULLUP даёт «инвертированную» логику: НЕ нажата = 1 (HIGH), нажата = 0 (LOW).
  // Поэтому сразу инвертируем, чтобы button = 1 означало «нажата».
  button = !digitalRead(buttonPin);

  // Вариант машины состояний:
  // Состояние A: buttonPressed == 0 (кнопка в «отжатом» состоянии). 
  // При нажатии (button == 1) и выдержке антидребезга — переключаем зелёный и переходим в состояние B.
  if (millis() - timerGreen > 5 and button == 1 and buttonPressed == 0) {
    digitalWrite(greenPin, !digitalRead(greenPin)); // Однократное переключение при нажатии
    timerGreen = millis();  // Сбрасываем таймер антидребезга
    buttonPressed = 1;      // Фиксируем, что мы уже обработали «нажатое» состояние
  }

  // Состояние B: buttonPressed == 1 (кнопка «считается» нажатой).
  // Ждём отпускания (button == 0) с выдержкой антидребезга — возвращаемся в состояние A.
  if (millis() - timerGreen > 5 and button == 0 and buttonPressed == 1) {
    timerGreen = millis();  // Снова сброс таймера для стабильности
    buttonPressed = 0;      // Разрешаем обработку следующего нажатия
  }
}

/*
────────────────────────────────────────────────────────────────────────────────
💡 ИДЕИ ДЛЯ УЛУЧШЕНИЙ

1) Типы и константы:
   - Замените int/long на более точные типы:
       const uint8_t redPin = 2;
       unsigned long timerRed = 0;
   - Интервалы сделайте константами: const unsigned long RED_INTERVAL = 100;

2) Универсальная функция мигания:
   Создайте функцию:
       void blink(uint8_t pin, unsigned long &timer, unsigned long interval) { ... }
   и используйте её для красного/жёлтого.

3) Больше состояний кнопки:
   Реализуйте короткое/длинное нажатие:
   - Если удержание > 1000 мс — зелёный включается постоянно.
   - Если короткое — просто переключение.

4) Стиль C++:
   - Вместо «and» используйте «&&» — так принято в большинстве команд/гайдлайнов.

УДАЧИ! И помните: отсутствие delay() — ваш главный инструмент для «параллельных» задач на микроконтроллере.
*/
