# Урок 1. Светодиоды, кнопка и `millis()` (без `delay()`)

Добро пожаловать в первый урок курса по промышленной робототехнике. Этот урок — «опорный»: здесь собраны все базовые знания, к которым можно возвращаться весь курс.
За этот урок соберёте простую схему на Arduino с тремя светодиодами и кнопкой, научитесь использовать встроенный подтягивающий резистор с  `INPUT_PULLUP`, реализуете **антидребезг** и **асинхронную** логику мигания на базе таймера `millis()` — без остановок `delay()`.

![Схема подключения](assets/scheme.png)

---

Скетчи:

V1 — мигание одним светодиодом c delay(): sketches/01_blink_delay/01_blink_delay.ino

V2 — «нажал — горит, отпустил — погас»: sketches/02_button_hold/02_button_hold.ino

V3 — мигание без delay() на millis(): sketches/03_blink_millis/03_blink_millis.ino

V4 — финал: три независимых мигания + кнопка: sketches/04_multi_blink_button/04_multi_blink_button.ino

---

## Что такое скетч. `setup()` и `loop()`

**Скетч** — программа для Arduino. В каждом скетче обязательно должны быть **две** главные функции:

* `setup()` — выполняется **один раз** при старте/сбросе. Здесь настраиваем пины, запускаем Serial и т.д.
* `loop()` — выполняется **бесконечно** — «основной поток» программы.

```cpp
void setup(){ 
  /* настройка пинов, периферии */ 
  }
void loop(){
    /* основная логика, повторяется всегда */ 
  }
```
* Обращайте внимание на фигурные скобки - в языке C++ они определяют структуру программы. 

---

## Пины и базовые команды

### Режим порта: `pinMode(pin, mode)`

* `OUTPUT` — выход (управляем, подаём 1/0). Применяется для управления светодиодами, моторами и т.д.
* `INPUT` — вход (сигнал читаем от датчиков, имеющих собственное питание)
* `INPUT_PULLUP` — вход с **внутренней** подтяжкой к +5 В. Применяется для кнопок

### Запись нового состояния в порт: `digitalWrite(pin, value)`

* `HIGH` — логическая 1 (на выходе ≈5 В)
* `LOW`  — логический 0 (на выходе 0 В)

### Чтение сосотояния из пина: `digitalRead(pin)`

* Возвращает `1` или `0`.
* При `INPUT_PULLUP`: **не нажато** → `1`, **нажато** → `0`.

Для обратной (более понятной и удобной, при обработке кнопки) логики применяется оператор `!` - инверсия.
`pressed = !digitalRead(pin)`
В переменную будет записываться **не нажато** → `0`, **нажато** → `1`.

### Время

* `delay(ms)` — **блокирующая** пауза на `ms` миллисекунд.
* `millis()` — время (мс) с момента старта (тип возвращаемого значения — `unsigned long`). Используется для **неблокирующих** таймеров.

---

## Типы данных, которые мы используем

* `int` / `int16_t`— целое со знаком. На UNO 16‑бит: от **−32768** до **32767**. Удобен для пинов/флагов в учебных примерах.
* `byte` / `uint8_t` — беззнаковый байт: от **0** до **255**. Хорош для индексов, состояний, пинов.
* `unsigned long` / `uint32_t` — беззнаковое 32х битное целое: от **0** до **4 294 967 295**. Используем для **времени** и таймеров, т.к. `millis()` возвращает именно его.

> **Почему `unsigned long` для времени?** Чтобы избежать проблем при вычитании и переполнении. Шаблон `if (millis() - t >= STEP)` корректно работает при переполнении счётчика.

---

## Управляющие конструкции

### `if` — условное выполнение

```cpp
if (условие) { /* да */ }
else { /* нет */ }
```

Сравнения: `==` (равно), `!=` (не равно), `<`(меньше), `>`(больше), `<=`(меньше или равно), `>=`(больше или равно). 
Логические операции для объединения условий: `&&` (И), `||` (ИЛИ), `!` (НЕ).

### `for` — цикл

```cpp
for (int i = 0; i < 3; i++) {
  //int i = 0 - создаем переменную-счетчик и присваиваем ей начальное значение
  //Условие продолжения работы цикла. Повторяем блок, пока условие истинно
  //i++ - увеличение счетчика на 1 на каждой интерации цикла
}
```

Полезен для обхода массивов пинов и массовых операций.

### `while` — цикл

```cpp
while (a < 100) {
  // повторяем блок, пока условие (a<100) истинно
}
```

Полезен для ожидания определенного события (пока не запустилось что-то)

---

## Быстрое решение «переключить состояние пина»

```cpp
digitalWrite(yellowPin, !digitalRead(yellowPin));
```

* `digitalRead(yellowPin)` вернёт `1` или `0`.
* `!` (логическое НЕ) инвертирует: `1 → 0`, `0 → 1`.
* `digitalWrite(...)` применяет новое состояние.

Так мы «переключаем» светодиод без отдельной переменной состояния.

---

# Скетчи урока

## V1 — мигание одним светодиодом с `delay()`

Файл: [`sketches/01_blink_delay/01_blink_delay.ino`](sketches/01_blink_delay/01_blink_delay.ino)

```cpp
int ledPin = 2;
void setup() {
  pinMode(ledPin, OUTPUT);
}
void loop() {
  digitalWrite(ledPin, 1);
  delay(500);
  digitalWrite(ledPin, 0);
  delay(500);
}
```

**Понимание:** просто, но блокирует процессор. Пока идёт `delay(500)`, остальные события «заморожены».

### Задания (V1)

1. Поменяй период мигания на 100 мс и 1000 мс.
2. Сделай «морзе»: длинная вспышка (800 мс), короткая (200 мс), пауза (400 мс) — по кругу.
3. Добавь еще один светодиод. Сделай мигание "по очереди"

---

## V2 — кнопка: «нажал — горит, отпустил — погас» (`INPUT_PULLUP`)

Файл: [`sketches/02_button_hold/02_button_hold.ino`](sketches/02_button_hold/02_button_hold.ino)

```cpp
int ledPin = 2;
int buttonPin = 5;
void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(buttonPin, INPUT_PULLUP);
}
void loop() {
  int pressed = !digitalRead(buttonPin);
  digitalWrite(ledPin, pressed);
}
```

**Понимание:** логика инвертирована, потому что `INPUT_PULLUP`. В переменную `pressed` считывается состояние кнопки (нажата или нет). И это состояние записывается в порт светодиода. 
Светодиод светится, когда кнопка нажата.

### Задания (V2)

1. Зажигай **три** светодиода (D2/D3/D4), когда кнопка нажата.
2. Поменяй условие: пусть горит **только** средний светодиод при нажатии, а два крайних, когда кнопка отпущена.

---

## V3 — мигание без `delay()` на `millis()`

Файл: [`sketches/03_blink_millis/03_blink_millis.ino`](sketches/03_blink_millis/03_blink_millis.ino)

```cpp
int ledPin = 2;
unsigned long timer = 0;
int STEP = 300;
void setup() {
  pinMode(ledPin, OUTPUT);
}
void loop() {
  if (millis() - timer >= STEP) {
    timer = millis();
    digitalWrite(ledPin, !digitalRead(ledPin));
  }
}
```

**Понимание:** неблокирующая «мигалка». Пока не пришло время действия — процессор свободен для других задач.

### Задания (V3)

1. Измени `STEP` и посмотри, когда мигание перестаёт быть заметным для глаза.
2. Сделай два независимых таймера: D2 мигает раз в 100 мс, D3 — раз в 700 мс.

---

## V4 — финальный скетч: три мигания + кнопка (`INPUT_PULLUP`)

Файл: [`sketches/04_multi_blink_button/04_multi_blink_button.ino`](sketches/04_multi_blink_button/04_multi_blink_button.ino)

```cpp
/*
================================================================================

СХЕМА ПОДКЛЮЧЕНИЯ 
- Красный светодиод (через резистор 220–330Ω) к D2 → другой вывод светодиода в GND.
- Жёлтый светодиод (через резистор 220–330Ω) к D3 → GND.
- Зелёный светодиод (через резистор 220–330Ω) к D4 → GND.
- Кнопка к D5 и GND. Внешний резистор НЕ нужен: мы включим INPUT_PULLUP!
  (Это значит: когда кнопка НЕ нажата — на входе логическая 1; когда нажата — логический 0)


ИДЕИ
- Никаких delay() — они «замораживают» процессор и мешают делать несколько задач сразу.
- millis() возвращает число миллисекунд с момента старта; мы сравниваем «текущее время – время_старта > интервал».
- Для устойчивой кнопки нужен антидребезг (обычно 10–50 мс). Здесь задано 5 мс — это «минимально допустимо».
- Логика кнопки инвертирована: из-за INPUT_PULLUP «нажато» = 0, «отжато» = 1. Мы переворачиваем её оператором инверсии «!».

- Тип таймеров лучше делать unsigned long (классический вариант Arduino против переполнения).
  В коде используется long — для учебной простоты, но в реальном коде меняйте на unsigned long.
- Оператор «and» — это допустимый синоним «&&» в C++. Для индустрии чаще используют «&&».
- Комплексирование операторов digitalWrite(pin, !digitalRead(pin)) удобен для «переключения».
- Интервалы выбраны разные (100 мс, 235 мс), чтобы показать независимость таймеров.

ПРАКТИКА (сделайте после запуска)
1) Измените длительность жёлтого мигания на 500 мс — посмотрите, как меняется рисунок.
2) Сделайте, чтобы зелёный светодиод менял состояние только при отпускании кнопки (событие «release»).
3) Превратите блок с красным/жёлтым в функцию blink(pin, interval, timer).
4) Усложнение: длинное нажатие (>1 с) включает зелёный постоянно, короткое — переключает.

ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ
- Почему delay() мешает мигать несколькими светодиодами одновременно?
- Чем хорош INPUT_PULLUP и почему кнопку подключаем к GND?
- Что такое «антидребезг» и для чего нужен флаг buttonPressed?
- Почему сравнивают «millis() - timer > interval», а не «millis() > timer + interval»?

================================================================================
*/

int greenPin  = 4;  // Пин зелёного светодиода 
int yellowPin = 3;  // Пин жёлтого светодиода
int redPin    = 2;  // Пин красного светодиода
int buttonPin = 5;  // Пин кнопки (кнопка между D5 и GND, включим INPUT_PULLUP)

// Таймеры для каждого независимого процесса мигания/дребезга.
long timerRed   = 0;
long timerYellow= 0;
long timerGreen = 0;

// Переменные для логики кнопки
int button = 0;          // Текущее состояние кнопки после инверсии (!digitalRead)
int buttonPressed = 0;   // Флаг «кнопка находится в нажатом состоянии» (машина состояний: 0→1→0)

/*
setup() — однократный вызов при старте.
- Выводы светодиодов — OUTPUT.
- Кнопка — INPUT_PULLUP (включает внутреннюю подтяжку к VCC → экономим резистор и места на макетке).
*/
void setup()
{
  pinMode(redPin,    OUTPUT);
  pinMode(yellowPin, OUTPUT);
  pinMode(greenPin,  OUTPUT);

  pinMode(buttonPin, INPUT_PULLUP); // НЕ нажата: HIGH (1). Нажата: LOW (0).
}

/*
loop() — главный цикл. В нём три независимых «задачи», каждая со своим таймером:
1) Красный мигает каждые ~100 мс.
2) Жёлтый мигает каждые ~235 мс.
3) Зелёный переключается при нажатии кнопки (с антидребезгом ~5 мс и флагом, чтобы не «дребезжало»).
*/
void loop() 
{
  // ────────────────────────────────────────────────────────────────────────────
  // 1) Асинхронное мигание КРАСНЫМ без delay()
  // Проверяем, прошло ли 100 мс с последнего переключения.
  if (millis() - timerRed > 100) {
    // Переключаем состояние вывода: если было 1 — станет 0, и наоборот.
    digitalWrite(redPin, !digitalRead(redPin));
    // Запоминаем «время последнего переключения»
    timerRed = millis();
  }

  // ────────────────────────────────────────────────────────────────────────────
  // 2) Асинхронное мигание ЖЁЛТЫМ без delay()
  if (millis() - timerYellow > 235) {
    digitalWrite(yellowPin, !digitalRead(yellowPin));
    timerYellow = millis();
  }

  // ────────────────────────────────────────────────────────────────────────────
  // 3) Обработка КНОПКИ с антидребезгом и флагом состояния
  // INPUT_PULLUP даёт «инвертированную» логику: НЕ нажата = 1 (HIGH), нажата = 0 (LOW).
  // Поэтому сразу инвертируем, чтобы button = 1 означало «нажата».
  button = !digitalRead(buttonPin);

  // Вариант машины состояний:
  // Состояние A: buttonPressed == 0 (кнопка в «отжатом» состоянии). 
  // При нажатии (button == 1) и выдержке антидребезга — переключаем зелёный и переходим в состояние B.
  if (millis() - timerGreen > 5 and button == 1 and buttonPressed == 0) {
    digitalWrite(greenPin, !digitalRead(greenPin)); // Однократное переключение при нажатии
    timerGreen = millis();  // Сбрасываем таймер антидребезга
    buttonPressed = 1;      // Фиксируем, что мы уже обработали «нажатое» состояние
  }

  // Состояние B: buttonPressed == 1 (кнопка «считается» нажатой).
  // Ждём отпускания (button == 0) с выдержкой антидребезга — возвращаемся в состояние A.
  if (millis() - timerGreen > 5 and button == 0 and buttonPressed == 1) {
    timerGreen = millis();  // Снова сброс таймера для стабильности
    buttonPressed = 0;      // Разрешаем обработку следующего нажатия
  }
}

```

**Понимание:**

* **Два независимых таймера** (красный/жёлтый) работают параллельно.
* Кнопка читаетcя в `INPUT_PULLUP`; «дребезг»  фильтруется порогом 5 мс на смену состояния (флаги `button`, `buttonPressed`).
* При нажатии зелёный **переключается один раз**.

### Задания (V4)

1. Сделай у зелёного собственный период мигания (например, 400 мс), **независимо** от кнопки.
2. Заставь зелёный **включаться только при удержании**.
3. Сделайте, чтобы зелёный переключался **по отпусканию** (событие *release*).
4. *Вынесите мигание красного/жёлтого в функцию `blink(pin, timer, interval)`.
5. *Реализуйте короткое (< 1000 мс) и длинное (≥ 1000 мс) нажатия — разные действия.


---

## Контрольные вопросы

1. Чем `delay(500)` отличается от конструкции  `millis() - timer > 500`? Когда что использовать?
2. Что возвращает `digitalRead()`? Почему при `INPUT_PULLUP` не нажато = `HIGH`?
3. Чем `int`, `byte` и `unsigned long` отличаются по диапазону и зачем использовать `unsigned long` для таймеров?
4. Что делает `!` в выражении `digitalWrite(pin, !digitalRead(pin));`?
5. Что выполняется раньше: `setup()` или `loop()`? Сколько раз они выполняются?
6. Какой режим у пина для кнопки с внутренней подтяжкой? Какая схема подключения?
7. Зачем нужен флаг `buttonPressed` в финальном скетче?
8. Почему `delay()` мешает параллельной работе нескольких задач?